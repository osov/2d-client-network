// Code generated by protgen; DO NOT EDIT.
import {DataHelper} from './DataHelper';

export interface IMessage{}

export interface IMessageData{
	typ:number;
	message:IMessage;
}

export interface ICsConnect extends IMessage{
	readonly idSession : string;	
}

export const MessageCsConnect = {

	Pack(view:DataHelper, message:ICsConnect): number {
		view.writeByte(MessageCsConnect.GetType());
		var len = this.PackMessage(message, view);
		return 1 + len;
	},

	PackMessage(message:ICsConnect, view:DataHelper):number {
		var a;
		const before = view.length;

		view.writeString(message.idSession);

		const after = view.length;
		return after - before;
	},

	UnPackMessage(view:DataHelper): ICsConnect {

		var prop_idSession = view.readString();

		var message:ICsConnect = {
				idSession : prop_idSession,
		};
		return message;
	},

	GetType(){
		return 0;
	},

	GetName(){
		return 'ICsConnect';
	}
}


export interface IScClose extends IMessage{	
}

export const MessageScClose = {

	Pack(view:DataHelper, message:IScClose): number {
		view.writeByte(MessageScClose.GetType());
		var len = this.PackMessage(message, view);
		return 1 + len;
	},

	PackMessage(message:IScClose, view:DataHelper):number {
		var a;
		const before = view.length;

		const after = view.length;
		return after - before;
	},

	UnPackMessage(view:DataHelper): IScClose {

		var message:IScClose = {
		};
		return message;
	},

	GetType(){
		return 1;
	},

	GetName(){
		return 'IScClose';
	}
}


export interface ICsPing extends IMessage{
	readonly clientTime : bigint;	
}

export const MessageCsPing = {

	Pack(view:DataHelper, message:ICsPing): number {
		view.writeByte(MessageCsPing.GetType());
		var len = this.PackMessage(message, view);
		return 1 + len;
	},

	PackMessage(message:ICsPing, view:DataHelper):number {
		var a;
		const before = view.length;

		if (message.clientTime < 0)
				throw new Error('protogen: protocol.cs_ping.client_time out of reach: '+ message.clientTime);
		if (message.clientTime > Number.MAX_SAFE_INTEGER)
			throw new Error('protogen: protocol.cs_ping.client_time exceeds Number.MAX_SAFE_INTEGER');
		view.writeUint64(message.clientTime);

		const after = view.length;
		return after - before;
	},

	UnPackMessage(view:DataHelper): ICsPing {

		var prop_clientTime = view.readUint64();

		var message:ICsPing = {
				clientTime : prop_clientTime,
		};
		return message;
	},

	GetType(){
		return 2;
	},

	GetName(){
		return 'ICsPing';
	}
}


export interface IScPong extends IMessage{
	readonly clientTime : bigint;
	readonly offsetTime : number;	
}

export const MessageScPong = {

	Pack(view:DataHelper, message:IScPong): number {
		view.writeByte(MessageScPong.GetType());
		var len = this.PackMessage(message, view);
		return 1 + len;
	},

	PackMessage(message:IScPong, view:DataHelper):number {
		var a;
		const before = view.length;

		if (message.clientTime < 0)
				throw new Error('protogen: protocol.sc_pong.client_time out of reach: '+ message.clientTime);
		if (message.clientTime > Number.MAX_SAFE_INTEGER)
			throw new Error('protogen: protocol.sc_pong.client_time exceeds Number.MAX_SAFE_INTEGER');
		view.writeUint64(message.clientTime);

		if (message.offsetTime > 4294967295 || message.offsetTime < 0)
			throw new Error('protogen: protocol.sc_pong.offset_time out of reach: '+ message.offsetTime);
		view.writeUint32(message.offsetTime);

		const after = view.length;
		return after - before;
	},

	UnPackMessage(view:DataHelper): IScPong {

		var prop_clientTime = view.readUint64();

		var prop_offsetTime = view.readUint32();

		var message:IScPong = {
				clientTime : prop_clientTime,
				offsetTime : prop_offsetTime,
		};
		return message;
	},

	GetType(){
		return 3;
	},

	GetName(){
		return 'IScPong';
	}
}


export interface IScTimestamp extends IMessage{
	readonly offsetTime : number;	
}

export const MessageScTimestamp = {

	Pack(view:DataHelper, message:IScTimestamp): number {
		view.writeByte(MessageScTimestamp.GetType());
		var len = this.PackMessage(message, view);
		return 1 + len;
	},

	PackMessage(message:IScTimestamp, view:DataHelper):number {
		var a;
		const before = view.length;

		if (message.offsetTime > 4294967295 || message.offsetTime < 0)
			throw new Error('protogen: protocol.sc_timestamp.offset_time out of reach: '+ message.offsetTime);
		view.writeUint32(message.offsetTime);

		const after = view.length;
		return after - before;
	},

	UnPackMessage(view:DataHelper): IScTimestamp {

		var prop_offsetTime = view.readUint32();

		var message:IScTimestamp = {
				offsetTime : prop_offsetTime,
		};
		return message;
	},

	GetType(){
		return 4;
	},

	GetName(){
		return 'IScTimestamp';
	}
}


export interface IScInit extends IMessage{
	readonly serverStartTime : bigint;
	readonly offsetTime : number;
	readonly idUser : number;
	readonly data : string;	
}

export const MessageScInit = {

	Pack(view:DataHelper, message:IScInit): number {
		view.writeByte(MessageScInit.GetType());
		var len = this.PackMessage(message, view);
		return 1 + len;
	},

	PackMessage(message:IScInit, view:DataHelper):number {
		var a;
		const before = view.length;

		if (message.serverStartTime < 0)
				throw new Error('protogen: protocol.sc_init.server_start_time out of reach: '+ message.serverStartTime);
		if (message.serverStartTime > Number.MAX_SAFE_INTEGER)
			throw new Error('protogen: protocol.sc_init.server_start_time exceeds Number.MAX_SAFE_INTEGER');
		view.writeUint64(message.serverStartTime);

		if (message.offsetTime > 4294967295 || message.offsetTime < 0)
			throw new Error('protogen: protocol.sc_init.offset_time out of reach: '+ message.offsetTime);
		view.writeUint32(message.offsetTime);

		if (message.idUser > 4294967295 || message.idUser < 0)
			throw new Error('protogen: protocol.sc_init.id_user out of reach: '+ message.idUser);
		view.writeUint32(message.idUser);

		view.writeString(message.data);

		const after = view.length;
		return after - before;
	},

	UnPackMessage(view:DataHelper): IScInit {

		var prop_serverStartTime = view.readUint64();

		var prop_offsetTime = view.readUint32();

		var prop_idUser = view.readUint32();

		var prop_data = view.readString();

		var message:IScInit = {
				serverStartTime : prop_serverStartTime,
				offsetTime : prop_offsetTime,
				idUser : prop_idUser,
				data : prop_data,
		};
		return message;
	},

	GetType(){
		return 5;
	},

	GetName(){
		return 'IScInit';
	}
}


export interface IVector2Int16 extends IMessage{
	readonly x : number;
	readonly y : number;	
}

export const MessageVector2Int16 = {

	Pack(view:DataHelper, message:IVector2Int16): number {
		view.writeByte(MessageVector2Int16.GetType());
		var len = this.PackMessage(message, view);
		return 1 + len;
	},

	PackMessage(message:IVector2Int16, view:DataHelper):number {
		var a;
		const before = view.length;

		if (message.x < -32768  || message.x > 32767)
			throw new Error('protogen: protocol.Vector2Int16.x exceeds 16-bit range: '+ message.x);
		view.writeInt16(message.x);

		if (message.y < -32768  || message.y > 32767)
			throw new Error('protogen: protocol.Vector2Int16.y exceeds 16-bit range: '+ message.y);
		view.writeInt16(message.y);

		const after = view.length;
		return after - before;
	},

	UnPackMessage(view:DataHelper): IVector2Int16 {

		var prop_x = view.readInt16();

		var prop_y = view.readInt16();

		var message:IVector2Int16 = {
				x : prop_x,
				y : prop_y,
		};
		return message;
	},

	GetType(){
		return 6;
	},

	GetName(){
		return 'IVector2Int16';
	}
}


export interface IVector2Uint8 extends IMessage{
	readonly x : number;
	readonly y : number;	
}

export const MessageVector2Uint8 = {

	Pack(view:DataHelper, message:IVector2Uint8): number {
		view.writeByte(MessageVector2Uint8.GetType());
		var len = this.PackMessage(message, view);
		return 1 + len;
	},

	PackMessage(message:IVector2Uint8, view:DataHelper):number {
		var a;
		const before = view.length;

		if (message.x > 255 || message.x < 0)
			throw new Error('protogen: protocol.Vector2Uint8.x out of reach: '+ message.x);
		view.writeByte(message.x);

		if (message.y > 255 || message.y < 0)
			throw new Error('protogen: protocol.Vector2Uint8.y out of reach: '+ message.y);
		view.writeByte(message.y);

		const after = view.length;
		return after - before;
	},

	UnPackMessage(view:DataHelper): IVector2Uint8 {

		var prop_x = view.readByte();

		var prop_y = view.readByte();

		var message:IVector2Uint8 = {
				x : prop_x,
				y : prop_y,
		};
		return message;
	},

	GetType(){
		return 7;
	},

	GetName(){
		return 'IVector2Uint8';
	}
}


export interface IEntityInfo extends IMessage{
	readonly id : number;
	readonly position : IVector2Int16;
	readonly velocity : IVector2Uint8;
	readonly angle : number;	
}

export const MessageEntityInfo = {

	Pack(view:DataHelper, message:IEntityInfo): number {
		view.writeByte(MessageEntityInfo.GetType());
		var len = this.PackMessage(message, view);
		return 1 + len;
	},

	PackMessage(message:IEntityInfo, view:DataHelper):number {
		var a;
		const before = view.length;

		if (message.id > 65535 || message.id < 0)
			throw new Error('protogen: protocol.EntityInfo.id out of reach: '+ message.id);
		view.writeUint16(message.id);

		MessageVector2Int16.PackMessage(message.position, view);

		MessageVector2Uint8.PackMessage(message.velocity, view);

		if (message.angle > 255 || message.angle < 0)
			throw new Error('protogen: protocol.EntityInfo.angle out of reach: '+ message.angle);
		view.writeByte(message.angle);

		const after = view.length;
		return after - before;
	},

	UnPackMessage(view:DataHelper): IEntityInfo {

		var prop_id = view.readUint16();

		var prop_position = MessageVector2Int16.UnPackMessage(view);

		var prop_velocity = MessageVector2Uint8.UnPackMessage(view);

		var prop_angle = view.readByte();

		var message:IEntityInfo = {
				id : prop_id,
				position : prop_position,
				velocity : prop_velocity,
				angle : prop_angle,
		};
		return message;
	},

	GetType(){
		return 8;
	},

	GetName(){
		return 'IEntityInfo';
	}
}


export interface IScWorldStateUpdate extends IMessage{
	readonly list : Array<IEntityInfo>;	
}

export const MessageScWorldStateUpdate = {

	Pack(view:DataHelper, message:IScWorldStateUpdate): number {
		view.writeByte(MessageScWorldStateUpdate.GetType());
		var len = this.PackMessage(message, view);
		return 1 + len;
	},

	PackMessage(message:IScWorldStateUpdate, view:DataHelper):number {
		var a;
		const before = view.length;

		a = message.list;
		view.writeVariant(a.length);
		a.forEach(function(it, vi) {
			if (it == null) 
				throw new Error('protogen: protocol.sc_world_state_update.list array is null: '+ message.list);
			MessageEntityInfo.PackMessage(it, view);
		});

		const after = view.length;
		return after - before;
	},

	UnPackMessage(view:DataHelper): IScWorldStateUpdate {

		var prop_list = [];
		var len = view.readVariant();
		for (var i = 0; i<len;i++){
			prop_list.push( MessageEntityInfo.UnPackMessage(view) );
		}

		var message:IScWorldStateUpdate = {
				list : prop_list,
		};
		return message;
	},

	GetType(){
		return 9;
	},

	GetName(){
		return 'IScWorldStateUpdate';
	}
}


export interface IScRemoveE extends IMessage{
	readonly idEntity : number;	
}

export const MessageScRemoveE = {

	Pack(view:DataHelper, message:IScRemoveE): number {
		view.writeByte(MessageScRemoveE.GetType());
		var len = this.PackMessage(message, view);
		return 1 + len;
	},

	PackMessage(message:IScRemoveE, view:DataHelper):number {
		var a;
		const before = view.length;

		if (message.idEntity > 65535 || message.idEntity < 0)
			throw new Error('protogen: protocol.sc_remove_e.id_entity out of reach: '+ message.idEntity);
		view.writeUint16(message.idEntity);

		const after = view.length;
		return after - before;
	},

	UnPackMessage(view:DataHelper): IScRemoveE {

		var prop_idEntity = view.readUint16();

		var message:IScRemoveE = {
				idEntity : prop_idEntity,
		};
		return message;
	},

	GetType(){
		return 10;
	},

	GetName(){
		return 'IScRemoveE';
	}
}


export interface ICsInput extends IMessage{
	readonly key : number;
	readonly state : number;	
}

export const MessageCsInput = {

	Pack(view:DataHelper, message:ICsInput): number {
		view.writeByte(MessageCsInput.GetType());
		var len = this.PackMessage(message, view);
		return 1 + len;
	},

	PackMessage(message:ICsInput, view:DataHelper):number {
		var a;
		const before = view.length;

		if (message.key > 255 || message.key < 0)
			throw new Error('protogen: protocol.cs_input.key out of reach: '+ message.key);
		view.writeByte(message.key);

		if (message.state > 255 || message.state < 0)
			throw new Error('protogen: protocol.cs_input.state out of reach: '+ message.state);
		view.writeByte(message.state);

		const after = view.length;
		return after - before;
	},

	UnPackMessage(view:DataHelper): ICsInput {

		var prop_key = view.readByte();

		var prop_state = view.readByte();

		var message:ICsInput = {
				key : prop_key,
				state : prop_state,
		};
		return message;
	},

	GetType(){
		return 11;
	},

	GetName(){
		return 'ICsInput';
	}
}


export interface ICsMouseAngle extends IMessage{
	readonly angle : number;	
}

export const MessageCsMouseAngle = {

	Pack(view:DataHelper, message:ICsMouseAngle): number {
		view.writeByte(MessageCsMouseAngle.GetType());
		var len = this.PackMessage(message, view);
		return 1 + len;
	},

	PackMessage(message:ICsMouseAngle, view:DataHelper):number {
		var a;
		const before = view.length;

		if (message.angle > 255 || message.angle < 0)
			throw new Error('protogen: protocol.cs_mouse_angle.angle out of reach: '+ message.angle);
		view.writeByte(message.angle);

		const after = view.length;
		return after - before;
	},

	UnPackMessage(view:DataHelper): ICsMouseAngle {

		var prop_angle = view.readByte();

		var message:ICsMouseAngle = {
				angle : prop_angle,
		};
		return message;
	},

	GetType(){
		return 12;
	},

	GetName(){
		return 'ICsMouseAngle';
	}
}


export interface IScJoin extends IMessage{
	readonly idUser : number;
	readonly idEntity : number;	
}

export const MessageScJoin = {

	Pack(view:DataHelper, message:IScJoin): number {
		view.writeByte(MessageScJoin.GetType());
		var len = this.PackMessage(message, view);
		return 1 + len;
	},

	PackMessage(message:IScJoin, view:DataHelper):number {
		var a;
		const before = view.length;

		if (message.idUser > 4294967295 || message.idUser < 0)
			throw new Error('protogen: protocol.sc_join.id_user out of reach: '+ message.idUser);
		view.writeUint32(message.idUser);

		if (message.idEntity > 65535 || message.idEntity < 0)
			throw new Error('protogen: protocol.sc_join.id_entity out of reach: '+ message.idEntity);
		view.writeUint16(message.idEntity);

		const after = view.length;
		return after - before;
	},

	UnPackMessage(view:DataHelper): IScJoin {

		var prop_idUser = view.readUint32();

		var prop_idEntity = view.readUint16();

		var message:IScJoin = {
				idUser : prop_idUser,
				idEntity : prop_idEntity,
		};
		return message;
	},

	GetType(){
		return 13;
	},

	GetName(){
		return 'IScJoin';
	}
}


export interface IScLeave extends IMessage{
	readonly idUser : number;
	readonly id : number;	
}

export const MessageScLeave = {

	Pack(view:DataHelper, message:IScLeave): number {
		view.writeByte(MessageScLeave.GetType());
		var len = this.PackMessage(message, view);
		return 1 + len;
	},

	PackMessage(message:IScLeave, view:DataHelper):number {
		var a;
		const before = view.length;

		if (message.idUser > 4294967295 || message.idUser < 0)
			throw new Error('protogen: protocol.sc_leave.id_user out of reach: '+ message.idUser);
		view.writeUint32(message.idUser);

		if (message.id > 65535 || message.id < 0)
			throw new Error('protogen: protocol.sc_leave.id out of reach: '+ message.id);
		view.writeUint16(message.id);

		const after = view.length;
		return after - before;
	},

	UnPackMessage(view:DataHelper): IScLeave {

		var prop_idUser = view.readUint32();

		var prop_id = view.readUint16();

		var message:IScLeave = {
				idUser : prop_idUser,
				id : prop_id,
		};
		return message;
	},

	GetType(){
		return 14;
	},

	GetName(){
		return 'IScLeave';
	}
}


export interface IEntityBase extends IMessage{
	readonly id : number;
	readonly position : IVector2Int16;	
}

export const MessageEntityBase = {

	Pack(view:DataHelper, message:IEntityBase): number {
		view.writeByte(MessageEntityBase.GetType());
		var len = this.PackMessage(message, view);
		return 1 + len;
	},

	PackMessage(message:IEntityBase, view:DataHelper):number {
		var a;
		const before = view.length;

		if (message.id > 65535 || message.id < 0)
			throw new Error('protogen: protocol.EntityBase.id out of reach: '+ message.id);
		view.writeUint16(message.id);

		MessageVector2Int16.PackMessage(message.position, view);

		const after = view.length;
		return after - before;
	},

	UnPackMessage(view:DataHelper): IEntityBase {

		var prop_id = view.readUint16();

		var prop_position = MessageVector2Int16.UnPackMessage(view);

		var message:IEntityBase = {
				id : prop_id,
				position : prop_position,
		};
		return message;
	},

	GetType(){
		return 15;
	},

	GetName(){
		return 'IEntityBase';
	}
}


export interface IEntityBullet extends IMessage{
	readonly id : number;
	readonly position : IVector2Int16;
	readonly velocity : IVector2Uint8;
	readonly angle : number;	
}

export const MessageEntityBullet = {

	Pack(view:DataHelper, message:IEntityBullet): number {
		view.writeByte(MessageEntityBullet.GetType());
		var len = this.PackMessage(message, view);
		return 1 + len;
	},

	PackMessage(message:IEntityBullet, view:DataHelper):number {
		var a;
		const before = view.length;

		if (message.id > 65535 || message.id < 0)
			throw new Error('protogen: protocol.EntityBullet.id out of reach: '+ message.id);
		view.writeUint16(message.id);

		MessageVector2Int16.PackMessage(message.position, view);

		MessageVector2Uint8.PackMessage(message.velocity, view);

		if (message.angle > 255 || message.angle < 0)
			throw new Error('protogen: protocol.EntityBullet.angle out of reach: '+ message.angle);
		view.writeByte(message.angle);

		const after = view.length;
		return after - before;
	},

	UnPackMessage(view:DataHelper): IEntityBullet {

		var prop_id = view.readUint16();

		var prop_position = MessageVector2Int16.UnPackMessage(view);

		var prop_velocity = MessageVector2Uint8.UnPackMessage(view);

		var prop_angle = view.readByte();

		var message:IEntityBullet = {
				id : prop_id,
				position : prop_position,
				velocity : prop_velocity,
				angle : prop_angle,
		};
		return message;
	},

	GetType(){
		return 16;
	},

	GetName(){
		return 'IEntityBullet';
	}
}



export const TypMessages = {
	0: MessageCsConnect,
	1: MessageScClose,
	2: MessageCsPing,
	3: MessageScPong,
	4: MessageScTimestamp,
	5: MessageScInit,
	6: MessageVector2Int16,
	7: MessageVector2Uint8,
	8: MessageEntityInfo,
	9: MessageScWorldStateUpdate,
	10: MessageScRemoveE,
	11: MessageCsInput,
	12: MessageCsMouseAngle,
	13: MessageScJoin,
	14: MessageScLeave,
	15: MessageEntityBase,
	16: MessageEntityBullet,
}

export const IdMessages = {
	ICsConnect:0,
	IScClose:1,
	ICsPing:2,
	IScPong:3,
	IScTimestamp:4,
	IScInit:5,
	IVector2Int16:6,
	IVector2Uint8:7,
	IEntityInfo:8,
	IScWorldStateUpdate:9,
	IScRemoveE:10,
	ICsInput:11,
	ICsMouseAngle:12,
	IScJoin:13,
	IScLeave:14,
	IEntityBase:15,
	IEntityBullet:16,
}

export const MessagesHelper = {
	PackCsConnect(view:DataHelper, message:ICsConnect): number{
		return MessageCsConnect.Pack(view, message);
	},

	PackScClose(view:DataHelper, message:IScClose): number{
		return MessageScClose.Pack(view, message);
	},

	PackCsPing(view:DataHelper, message:ICsPing): number{
		return MessageCsPing.Pack(view, message);
	},

	PackScPong(view:DataHelper, message:IScPong): number{
		return MessageScPong.Pack(view, message);
	},

	PackScTimestamp(view:DataHelper, message:IScTimestamp): number{
		return MessageScTimestamp.Pack(view, message);
	},

	PackScInit(view:DataHelper, message:IScInit): number{
		return MessageScInit.Pack(view, message);
	},

	PackVector2Int16(view:DataHelper, message:IVector2Int16): number{
		return MessageVector2Int16.Pack(view, message);
	},

	PackVector2Uint8(view:DataHelper, message:IVector2Uint8): number{
		return MessageVector2Uint8.Pack(view, message);
	},

	PackEntityInfo(view:DataHelper, message:IEntityInfo): number{
		return MessageEntityInfo.Pack(view, message);
	},

	PackScWorldStateUpdate(view:DataHelper, message:IScWorldStateUpdate): number{
		return MessageScWorldStateUpdate.Pack(view, message);
	},

	PackScRemoveE(view:DataHelper, message:IScRemoveE): number{
		return MessageScRemoveE.Pack(view, message);
	},

	PackCsInput(view:DataHelper, message:ICsInput): number{
		return MessageCsInput.Pack(view, message);
	},

	PackCsMouseAngle(view:DataHelper, message:ICsMouseAngle): number{
		return MessageCsMouseAngle.Pack(view, message);
	},

	PackScJoin(view:DataHelper, message:IScJoin): number{
		return MessageScJoin.Pack(view, message);
	},

	PackScLeave(view:DataHelper, message:IScLeave): number{
		return MessageScLeave.Pack(view, message);
	},

	PackEntityBase(view:DataHelper, message:IEntityBase): number{
		return MessageEntityBase.Pack(view, message);
	},

	PackEntityBullet(view:DataHelper, message:IEntityBullet): number{
		return MessageEntityBullet.Pack(view, message);
	},

	UnPackMessages(view:DataHelper, buffer:Uint8Array):Array<IMessageData>{
		var messages:Array<IMessageData> = [];
		view.startReading(buffer);
		while(view.index < view.length){
			var _typ = view.readByte();
			var packer:any = TypMessages[_typ as keyof IMessage];
			if (packer === undefined)
				throw new Error('protogen: packer not found:'+_typ);
			var _message = packer.UnPackMessage(view);
			messages.push({typ:_typ, message:_message});
		}
		return messages;
	}
}

